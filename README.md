# ripple-sign-serialize
 
[![CircleCI](https://circleci.com/gh/ximinez/ripple-sign-serialize.svg?style=svg)](https://circleci.com/gh/ximinez/ripple-sign-serialize)
[![Build Status](https://travis-ci.org/ximinez/ripple-sign-serialize.svg?branch=master)](https://travis-ci.org/ximinez/ripple-sign-serialize)
[![Build status](https://ci.appveyor.com/api/projects/status/3h1nd3xfprcimtbd?svg=true)](https://ci.appveyor.com/project/ximinez/ripple-sign-serialize)
[![codecov](https://codecov.io/gh/ximinez/ripple-sign-serialize/branch/master/graph/badge.svg)](https://codecov.io/gh/ximinez/ripple-sign-serialize)

Rippled serialization and transaction signing command-line tool

## Table of contents

* [Dependencies](#dependencies)
  * [ripple-libpp submodule](#ripple-libpp-submodule)
  * [Other dependencies](#other-dependencies)
* [Build and run](#build-and-run)
* [Guide](#guide)
  * [Key File Format](#key-file-format)

## Dependencies

### ripple-libpp submodule

This includes a git submodule to the ripple-libpp source code, which is not cloned by default. To get the ripple-libpp source, either clone this repository using
```
$ git clone --recursive <location>
```
or after cloning, run the following commands
```
$ git submodule update --init --recursive
```

### Other dependencies

* C++14 or greater
* [Boost](http://www.boost.org/)
* [OpenSSL](https://www.openssl.org/)
* [cmake](https://cmake.org)

## Build and run

For linux and other unix-like OSes, run the following commands:

```
$ cd ${YOUR_RIPPLE_SERIALIZE_DIRECTORY}
$ mkdir -p build/gcc.debug
$ cd build/gcc.debug
$ cmake ../..
$ cmake --build .
$ ./ripple-serialize --unittest
$ ./ripple-serialize --help
```

For 64-bit Windows, open a MSBuild Command Prompt for Visual Studio
and run the following commands:

```
> cd %YOUR_RIPPLE_SERIALIZE_DIRECTORY%
> mkdir build
> cd build
> cmake -G"Visual Studio 14 2015 Win64" ..
> cmake --build .
> .\Debug\ripple-serialize.exe --unittest
> .\Debug\ripple-serialize.exe --help
```

32-bit Windows builds are not officially supported.

# Guide

```
ripple-serialize [options] <command> [<argument> ...]
General Options:
  -h [ --help ]         Display this message.
  --keyfile arg         Specify the key file.
  -u [ --unittest ]     Perform unit tests.
  --version             Display the build version.

Commands:
  Serialization:
    serialize [<argument>]              Serialize from JSON.
    deserialize [<argument>]            Deserialize to JSON.

  Transaction signing:
    sign [<argument>]                   Sign for submission.
    multiSign [<argument>]              Apply a multi-signature.
      Signing commands require a valid keyfile.
      Input can be serialized or unserialized JSON.
      Output will always be unserialized JSON.

      If an <argument> is not provided, the data will be
      read from stdin.

  Key Management:
    create_keyfile [<keytype> [<seed>]] Create a new keyfile.
      Specifying <seed> on the command line is strongly discouraged,
      particularly on a shared machine. Instead, create a random seed,
      edit the keyfile "master_seed", then run repair_keyfile.
    repair_keyfile                      Resync "master_seed"-derived fields.
```

For any operations that require a keyfile (`sign`, `multiSign`, `create_keyfile`,
`repair_keyfile`), `ripple-serialize` will look in `${HOME}/.ripple/secret-key.txt`
if one is not specified with the `--keyfile` option.

None of the serialization or signing operations will write anything to disk. Results
are send to standard output. This allows commands to be chained. For example:
```
ripple-serialize --keyfile mykey.txt sign < pendingtx.txt | ripple-serialize serialize
```

`create_keyfile` will not overwrite an existing file. `repair_keyfile` will overwrite
the keyfile, but only if it is valid.

## Key File Format

The key file contains one JSON object. That object has a series of string name/value
pairs. The only required fields are `key_type` and `master_seed`. Other fields are
derived internally as needed. This simplifies keyfile creation for existing ripple
accounts. Example:

```
{
      "key_type" : "ed25519",
      "master_seed" : "sPUTYOURSECRETKEYHERE"
}
```

For user convenience, the `create_keyfile` operation will write a new keyfile
containing the same fields returned by `rippled`'s `wallet_propose` RPC command
plus `secret_key` and `secret_key_hex`. While not needed for signing operations,
this allows the user to easily retrieve or confirm their `account_id` for later
use. It also removes the risk of allowing a potentially untrusted server to
generate a secret key.

Finally, the `repair_keyfile` operation will read the `key_type` and `master_seed`
fields, then rewrite the keyfile to add or update all of the other key fields as
if generated by `create_keyfile`. On a manually created or edited keyfile, this
brings the other fields back into sync and allows the user to verify that it was
entered correctly by matching other known fields, such as `account_id`.
